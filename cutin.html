<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MegaFuture — Story Modal (Timed Cues)</title>

  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#000;
      --text:rgba(255,255,255,.72);
      --panel:rgba(0,0,0,.82);
      --panel-border:rgba(255,255,255,.08);
    }

    html, body{
      margin:0;
      height:100%;
      background:var(--bg);
      overflow:hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    #mfModal{
      position:fixed;
      inset:0;
      display:grid;
      place-items:center;
      background:#000;
      user-select:none;
      overflow:hidden;
    }

    .stage{
      width:min(92vw, 1100px);
      aspect-ratio:16/9;
      position:relative;
      display:grid;
      place-items:center;
      border-radius:18px;
      overflow:hidden;
      background:#000;
    }

    /* ===== Background stack behind actors (no crop) ===== */
    .bgStack{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index: 1;

      opacity: 0;
      transition: opacity 2800ms ease;

      transform: scale(1);
      transform-origin: center center;
      will-change: transform, opacity;
    }
    .bgStack.isVisible{ opacity: 1; }

    .bgFrame{
      position:absolute;
      inset:0;
      background-position: center center;
      background-repeat: no-repeat;
      background-size: contain;

      opacity: 0;
      transition: opacity 900ms ease;
      will-change: opacity;
    }
    .bgFrame.isOn{ opacity: 1; }

    /* NEW: simultaneous fadeout (bg2..bg5 only) */
    .bgFrame.fadeOut{
      opacity: 0 !important;
    }

    .charLayer{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index: 2;

      opacity: 0;
      transition: opacity 1400ms ease;
    }
    .charLayer.isVisible{ opacity: 1; }

    .captionBar{
      position:absolute;
      left:0;
      right:0;
      bottom:0;
      height:28%;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding: 0 18px 18px;
      box-sizing:border-box;
      background: linear-gradient(to top, rgba(0,0,0,.92), rgba(0,0,0,.10) 70%, rgba(0,0,0,0));
      pointer-events:none;
      z-index: 3;
    }

    .captionPanel{
      width:min(92%, 900px);
      min-height: 84px;
      max-height: 160px;
      padding: 14px 16px;
      box-sizing:border-box;
      border-radius: 14px;
      background: var(--panel);
      border: 1px solid var(--panel-border);
      backdrop-filter: blur(6px);
      display:flex;
      align-items:center;
      justify-content:center;
    }

    #captionText{
      font-family: "Orbitron", system-ui, sans-serif;
      font-weight: 500;
      font-size: clamp(12px, 1.45vw, 16px);
      line-height: 1.45;
      letter-spacing: 0.02em;
      text-align:center;
      color: var(--text);
      white-space: pre-wrap;
      min-height: 1.5em;
      width:100%;
      transition: opacity 260ms ease;
    }

    .card{
      position:absolute;
      top: 10%;
      display:inline-block;
      width:auto;
      height:auto;
      background: transparent;
      border: none;
      box-shadow: none;
      will-change: transform;
      transform-origin: center center;
    }

    #amadeusCard{ z-index: 4; }
    #aristocratCard{ z-index: 3; }

    .card img{
      display:block;
      width:auto;
      height:auto;
      max-width: min(40vw, 520px);
      max-height: min(58vh, 600px);
      object-fit: contain;
      background: transparent;
    }

    #debug{
      position:fixed;
      left:12px;
      top:12px;
      padding:8px 10px;
      border-radius:10px;
      color:rgba(255,255,255,.55);
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.08);
      font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      white-space:pre;
      user-select:none;
      pointer-events:none;
      display:none;
    }
  </style>
</head>

<body>
  <div id="debug"></div>

  <div id="mfModal">
    <div class="stage" id="stage">

      <!-- Background stack -->
      <div class="bgStack" id="bgStack" aria-hidden="true">
        <div class="bgFrame" id="bg1"></div>
        <div class="bgFrame" id="bg2"></div>
        <div class="bgFrame" id="bg3"></div>
        <div class="bgFrame" id="bg4"></div>
        <div class="bgFrame" id="bg5"></div>
      </div>

      <div class="charLayer" id="charLayer">
        <div class="card" id="amadeusCard" aria-hidden="true"></div>
        <div class="card" id="aristocratCard" aria-hidden="true"></div>
      </div>

      <div class="captionBar">
        <div class="captionPanel">
          <div id="captionText"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
  (() => {
    const AMADEUS_IMG    = "images/amadeus.png";
    const ARISTOCRAT_IMG = "images/aristocrat.png";

    // Background frames
    const BLOOD_BAY_1 = "images/blood_bay_1.png";
    const BLOOD_BAY_2 = "images/blood_bay_2.png";
    const BLOOD_BAY_3 = "images/blood_bay_3.png";
    const BLOOD_BAY_4 = "images/blood_bay_4.png";
    const BLOOD_BAY_5 = "images/blood_bay_5.png";

    // Fade cues
    const BG_FADE_ON_TEXT = "It is a time when the sun burns weak and red.";
    const ACTORS_FADE_ON_EXACT = "These \"men,\" as they once fashioned themselves.";

    // Background step triggers
    const BG2_ON_TEXT = "You are of the two remaining immortals.";
    const BG3_ON_TEXT = "A clone.";
    const BG4_ON_TEXT = "An experiment.";
    const BG5_ON_TEXT = "A prisoner.";

    // NEW: after "A prisoner." cleanup timing
    const PRISONER_WAIT_BEFORE_CLEANUP_MS = 4000;   // wait 4s
    const PRISONER_EXTRA_WAIT_BEFORE_ACTORS_MS = 2000; // then wait 2s
    const BG_FADE_OUT_MS = 900; // must match CSS transition for .bgFrame

    // Motion timing
    const MOVE_MS = 24000;
    const SOLO_SLIDE_MS = 8000;

    // Zoom and synced background shrink (2x faster)
    const ZOOM_FROM = 1.00;
    const ZOOM_TO   = 1.22;
    const ZOOM_EASE = "linear";

    const BG_SCALE_FROM = 1.00;
    const BG_SCALE_TO   = 0.88;

    const MOVE_EASE = "cubic-bezier(0.10, 0.00, 0.90, 1.00)";
    const SOLO_EASE = "cubic-bezier(0.10, 0.00, 0.90, 1.00)";

    const DELETE_BLUE_ON_TEXT = "In their infighting, only one remained.";
    const EXTRA_HOLD_BEFORE_DELETE_MS = 5000;
    const DELAY_BEFORE_RED_RECENTER_MS = 2000;

    const storyCues = [
      { text: "It is a time when the sun burns weak and red.", ms: 4000 },
      { text: "The days are long and the seasons are cold.", ms: 5000 },
      { text: "This is The MegaFuture", ms: 3000 },
      { text: "", ms: 900 },

      { text: "You are of the two remaining immortals.", ms: 4000 },
      { text: "A clone.", ms: 2400 },
      { text: "An experiment.", ms: 2400 },
      { text: "A prisoner.", ms: 2400 },
      { text: "", ms: 900 },

      { text: "These \"men,\" as they once fashioned themselves.", ms: 4000 },
      { text: "Poisoned the Earth.", ms: 3000 },
      { text: "Hardened their bodies.", ms: 3000 },
      { text: "And created a cabal of everlasting corruption.", ms: 4000 },
      { text: "In their infighting, only one remained.", ms: 4000 },
      { text: "", ms: 2000 },

      { text: "A single authority with absolute control over Earth’s biosphere.", ms: 3400 },
      { text: "Over life.", ms: 2300 },
      { text: "Over death.", ms: 2300 },
      { text: "", ms: 1800 },

      { text: "Over you.", ms: 3400 },
      { text: "", ms: 900 },

      { text: "Your goal is to escape this madness.", ms: 3400 },
      { text: "but...", ms: 3000 },
      { text: "is it even possible?", ms: 3400 }
    ];

    const stage = document.getElementById("stage");
    const captionText = document.getElementById("captionText");
    const debugEl = document.getElementById("debug");

    const bgStack = document.getElementById("bgStack");
    const bg1 = document.getElementById("bg1");
    let bg2 = document.getElementById("bg2");
    let bg3 = document.getElementById("bg3");
    let bg4 = document.getElementById("bg4");
    let bg5 = document.getElementById("bg5");

    const charLayer = document.getElementById("charLayer");
    const amadeusCard = document.getElementById("amadeusCard");
    let aristocratCard = document.getElementById("aristocratCard");

    const wait = (ms) => new Promise(r => setTimeout(r, ms));

    function setDebug(txt){
      if (!debugEl || debugEl.style.display === "none") return;
      debugEl.textContent = txt;
    }

    function setCaptionText(str){
      captionText.style.opacity = "0";
      const safe = (str === "") ? " " : str;
      setTimeout(() => {
        captionText.textContent = safe;
        captionText.style.opacity = "1";
      }, 170);
    }

    function mountImage(cardEl, url){
      return new Promise((resolve) => {
        const img = new Image();
        img.decoding = "async";
        img.loading = "eager";
        img.src = url;

        img.onload = () => {
          cardEl.innerHTML = "";
          cardEl.appendChild(img);
          resolve(true);
        };

        img.onerror = () => resolve(false);
      });
    }

    function setBgFrame(el, url){
      if (!el) return;
      el.style.backgroundImage = `url("${url}")`;
    }

    function preloadImages(urls){
      return Promise.all(urls.map(url => new Promise((resolve) => {
        const img = new Image();
        img.decoding = "async";
        img.loading = "eager";
        img.src = url;
        img.onload = () => resolve(true);
        img.onerror = () => resolve(false);
      })));
    }

    // ---- background transform management ----
    let bgScale = BG_SCALE_FROM;
    function applyBgTransform(){ bgStack.style.transform = `scale(${bgScale})`; }
    function setBgScale(s){ bgScale = s; applyBgTransform(); }

    // ---- transform management (translate + scale together) ----
    let amadeusX = 0;
    let amadeusScale = ZOOM_FROM;

    function applyAmadeusTransform(){
      amadeusCard.style.transform = `translate3d(${amadeusX}px, 0px, 0px) scale(${amadeusScale})`;
    }
    function setAmadeusX(x){ amadeusX = x; applyAmadeusTransform(); }
    function setAmadeusScale(s){ amadeusScale = s; applyAmadeusTransform(); }

    // ---- positions / motion ----
    function computePositions(){
      const rect = stage.getBoundingClientRect();
      const aRect = amadeusCard.getBoundingClientRect();
      const cardW = aRect.width;

      const padX = Math.max(18, rect.width * 0.035);

      const leftStartX  = padX;
      const rightStartX = rect.width - padX - cardW;

      const leftEndX  = rightStartX;
      const rightEndX = leftStartX;

      const centerX = (rect.width - cardW) / 2;
      return { leftStartX, rightStartX, leftEndX, rightEndX, centerX };
    }

    function setCardX(cardEl, x){
      cardEl.style.transform = `translate3d(${x}px, 0px, 0px)`;
    }

    function snapToDefaultPositions(){
      const pos = computePositions();
      amadeusCard.style.transition = "none";
      if (aristocratCard && aristocratCard.isConnected) aristocratCard.style.transition = "none";

      setAmadeusScale(ZOOM_FROM);
      setAmadeusX(pos.leftStartX);

      if (aristocratCard && aristocratCard.isConnected){
        setCardX(aristocratCard, pos.rightStartX);
      }

      bgStack.style.transition = "none";
      setBgScale(BG_SCALE_FROM);

      void amadeusCard.offsetHeight;
    }

    function animateSwapOnce(){
      const pos = computePositions();

      amadeusCard.style.transition = `transform ${MOVE_MS}ms ${MOVE_EASE}`;
      if (aristocratCard && aristocratCard.isConnected){
        aristocratCard.style.transition = `transform ${MOVE_MS}ms ${MOVE_EASE}`;
      }

      requestAnimationFrame(() => {
        setAmadeusX(pos.leftEndX);
        if (aristocratCard && aristocratCard.isConnected){
          setCardX(aristocratCard, pos.rightEndX);
        }
      });
    }

    function animateRedToCenter(){
      const pos = computePositions();
      amadeusCard.style.transition = `transform ${SOLO_SLIDE_MS}ms ${SOLO_EASE}`;
      requestAnimationFrame(() => setAmadeusX(pos.centerX));
    }

    function isDeleteCueText(text){
      if (!text) return false;
      return text === DELETE_BLUE_ON_TEXT || text.includes(DELETE_BLUE_ON_TEXT);
    }

    function calcZoomDurationAfterDelete(){
      const idx = storyCues.findIndex(c => isDeleteCueText(c.text));
      if (idx === -1) return 0;
      let sum = 0;
      for (let i = idx + 1; i < storyCues.length; i++){
        sum += (storyCues[i]?.ms || 0);
      }
      return Math.max(0, sum);
    }

    function startAmadeusZoomAndBgShrinkUntilStoryEnds(){
      const zoomDuration = calcZoomDurationAfterDelete() / 2; // 2x faster
      if (zoomDuration <= 0){
        setAmadeusScale(ZOOM_TO);
        setBgScale(BG_SCALE_TO);
        return;
      }

      amadeusCard.style.transition = `transform ${zoomDuration}ms ${ZOOM_EASE}`;
      bgStack.style.transition     = `transform ${zoomDuration}ms ${ZOOM_EASE}`;

      requestAnimationFrame(() => {
        setAmadeusScale(ZOOM_TO);
        setBgScale(BG_SCALE_TO);
      });
    }

    let blueDeleted = false;
    let zoomStarted = false;

    function deleteBlueNow(){
      if (blueDeleted) return;
      blueDeleted = true;

      if (aristocratCard && aristocratCard.isConnected){
        aristocratCard.remove();
      }
      aristocratCard = null;

      setTimeout(() => {
        animateRedToCenter();

        if (!zoomStarted){
          zoomStarted = true;
          setTimeout(() => startAmadeusZoomAndBgShrinkUntilStoryEnds(), SOLO_SLIDE_MS);
        }
      }, DELAY_BEFORE_RED_RECENTER_MS);
    }

    // ---- staged start ----
    let bgShown = false;
    let actorsShown = false;
    let motionStarted = false;

    // background progression
    let bg2On = false, bg3On = false, bg4On = false, bg5On = false;

    // NEW: prisoner cleanup state + actor scheduling
    let cleanupStarted = false;
    let cleanupDoneAt = 0;              // performance.now() timestamp when actors may appear
    let actorsRevealScheduled = false;  // avoid double scheduling

    function showBackgroundIfNeeded(text){
      if (bgShown) return;
      if (!text) return;
      if (text === BG_FADE_ON_TEXT || text.includes(BG_FADE_ON_TEXT)){
        bgShown = true;
        bgStack.classList.add("isVisible");
      }
    }

    function startPrisonerCleanupTimeline(){
      if (cleanupStarted) return;
      cleanupStarted = true;

      // compute when actors are allowed to appear:
      // now + 4s + fadeOutMs + 2s
      const now = performance.now();
      cleanupDoneAt = now + PRISONER_WAIT_BEFORE_CLEANUP_MS + BG_FADE_OUT_MS + PRISONER_EXTRA_WAIT_BEFORE_ACTORS_MS;

      (async () => {
        await wait(PRISONER_WAIT_BEFORE_CLEANUP_MS);

        // fade out bg2..bg5 simultaneously
        [bg2, bg3, bg4, bg5].forEach(el => {
          if (el && el.isConnected) el.classList.add("fadeOut");
        });

        await wait(BG_FADE_OUT_MS);

        // delete bg2..bg5 from DOM
        [bg2, bg3, bg4, bg5].forEach(el => {
          if (el && el.isConnected) el.remove();
        });

        bg2 = bg3 = bg4 = bg5 = null;

        // (we DON'T trigger actors here; we only "allow" them — reveal is still tied to These men)
      })();
    }

    function progressBackgroundFramesIfNeeded(text){
      if (!text) return;

      if (!bg2On && (text === BG2_ON_TEXT || text.includes(BG2_ON_TEXT))){
        bg2On = true;
        bg2?.classList.add("isOn");
        return;
      }
      if (!bg3On && (text === BG3_ON_TEXT || text.includes(BG3_ON_TEXT))){
        bg3On = true;
        bg3?.classList.add("isOn");
        return;
      }
      if (!bg4On && (text === BG4_ON_TEXT || text.includes(BG4_ON_TEXT))){
        bg4On = true;
        bg4?.classList.add("isOn");
        return;
      }
      if (!bg5On && (text === BG5_ON_TEXT || text.includes(BG5_ON_TEXT))){
        bg5On = true;
        bg5?.classList.add("isOn");
        // kick the cleanup timeline right after prisoner turns on
        startPrisonerCleanupTimeline();
        return;
      }
    }

    function revealActorsAndStartMotion(){
      if (actorsShown) return;
      actorsShown = true;

      charLayer.classList.add("isVisible");

      if (!motionStarted){
        motionStarted = true;
        requestAnimationFrame(() => animateSwapOnce());
      }
    }

// NOTE: we no longer reveal actors here for the "These men..." cue,
// because we want caption + actor reveal to happen at the same moment.
// So this function can stay for other triggers if you want, but here it does nothing.
function showActorsAndStartMotionIfNeeded(text){
  // intentionally no-op for ACTORS_FADE_ON_EXACT
}

async function playStory(){
  for (let i = 0; i < storyCues.length; i++){
    const cue = storyCues[i];

    // Always progress background + cleanup scheduling based on the raw cue text
    showBackgroundIfNeeded(cue.text);
    progressBackgroundFramesIfNeeded(cue.text);

    // SPECIAL: sync "These men" caption to actor reveal time (when cleanup is involved)
    const isTheseMen = cue.text && (cue.text === ACTORS_FADE_ON_EXACT || cue.text.includes(ACTORS_FADE_ON_EXACT));

    if (isTheseMen && cleanupStarted && !actorsShown){
      // Wait until the cleanup timeline finishes (4s + fade + 2s), then show caption + actors together
      const delay = Math.max(0, cleanupDoneAt - performance.now());
      if (delay > 0) await wait(delay);

      // Now: caption appears + actors fade in at the same time
      setCaptionText(cue.text);
      revealActorsAndStartMotion();

      // Hold this cue's duration AFTER it becomes visible
      await wait(cue.ms);
      continue;
    }

    // Normal behavior for all other cues
    setCaptionText(cue.text);

    // Actor reveal when there's no cleanup gating (original behavior)
    if (isTheseMen && !cleanupStarted){
      revealActorsAndStartMotion();
    }

    if (isDeleteCueText(cue.text)){
      await wait(cue.ms + EXTRA_HOLD_BEFORE_DELETE_MS);
      deleteBlueNow();
      continue;
    }

    await wait(cue.ms);
  }
}

    async function init(){
      bgStack.classList.remove("isVisible");
      charLayer.classList.remove("isVisible");

      // set background images
      setBgFrame(bg1, BLOOD_BAY_1);
      setBgFrame(bg2, BLOOD_BAY_2);
      setBgFrame(bg3, BLOOD_BAY_3);
      setBgFrame(bg4, BLOOD_BAY_4);
      setBgFrame(bg5, BLOOD_BAY_5);

      bg1.classList.add("isOn");

      await preloadImages([BLOOD_BAY_1, BLOOD_BAY_2, BLOOD_BAY_3, BLOOD_BAY_4, BLOOD_BAY_5]);

      await Promise.all([
        mountImage(amadeusCard, AMADEUS_IMG),
        mountImage(aristocratCard, ARISTOCRAT_IMG)
      ]);

      snapToDefaultPositions();

      setCaptionText(storyCues[0]?.text ?? " ");
      showBackgroundIfNeeded(storyCues[0]?.text ?? "");

      playStory();

      addEventListener("resize", () => {
        if (!motionStarted){
          snapToDefaultPositions();
        }
        setDebug("resized");
      }, { passive:true });
    }

    init().catch(err => {
      console.error(err);
      setCaptionText(" ");
    });
  })();
  </script>
</body>
</html>